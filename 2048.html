import React, { useState, useEffect, useCallback } from 'react';
import { RotateCcw, Trophy } from 'lucide-react';

const Game2048 = () => {
  const [grid, setGrid] = useState([]);
  const [score, setScore] = useState(0);
  const [bestScore, setBestScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [won, setWon] = useState(false);

  // --- Logic Kh·ªüi t·∫°o v√† L∆∞·ªõi ---

  const initGrid = useCallback(() => {
    const newGrid = Array(4).fill(null).map(() => Array(4).fill(0));
    addNewTile(newGrid);
    addNewTile(newGrid);
    return newGrid;
  }, []);

  useEffect(() => {
    // Kh·ªüi t·∫°o tr·∫°ng th√°i game v√† ƒëi·ªÉm cao nh·∫•t
    setGrid(initGrid());
    const savedBest = localStorage.getItem('best2048') || 0;
    setBestScore(parseInt(savedBest));
  }, [initGrid]);

  const addNewTile = (currentGrid) => {
    const emptyCells = [];
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        if (currentGrid[i][j] === 0) {
          emptyCells.push({ i, j });
        }
      }
    }
    if (emptyCells.length > 0) {
      const { i, j } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      // 90% c∆° h·ªôi l√† 2, 10% c∆° h·ªôi l√† 4
      currentGrid[i][j] = Math.random() < 0.9 ? 2 : 4;
    }
  };

  const checkGameOver = (grid) => {
    // Ki·ªÉm tra √¥ tr·ªëng
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        if (grid[i][j] === 0) return false;
        // Ki·ªÉm tra kh·∫£ nƒÉng h·ª£p nh·∫•t ngang
        if (j < 3 && grid[i][j] === grid[i][j + 1]) return false;
        // Ki·ªÉm tra kh·∫£ nƒÉng h·ª£p nh·∫•t d·ªçc
        if (i < 3 && grid[i][j] === grid[i + 1][j]) return false;
      }
    }
    return true;
  };

  const rotateGrid = (grid) => {
    // Quay l∆∞·ªõi 90 ƒë·ªô theo chi·ªÅu kim ƒë·ªìng h·ªì
    const newGrid = Array(4).fill(null).map(() => Array(4).fill(0));
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        newGrid[j][3 - i] = grid[i][j];
      }
    }
    return newGrid;
  };

  // --- Logic Di chuy·ªÉn ---

  const moveLeft = (grid) => {
    let newGrid = grid.map(row => [...row]);
    let moved = false;
    let addedScore = 0;

    for (let i = 0; i < 4; i++) {
      let row = newGrid[i].filter(val => val !== 0); // Lo·∫°i b·ªè s·ªë 0
      
      // H·ª£p nh·∫•t
      for (let j = 0; j < row.length - 1; j++) {
        if (row[j] === row[j + 1]) {
          row[j] *= 2;
          addedScore += row[j];
          row.splice(j + 1, 1); // X√≥a √¥ ƒë√£ h·ª£p nh·∫•t
          if (row[j] === 2048 && !won) {
            setWon(true);
          }
        }
      }
      
      // Th√™m s·ªë 0 v√†o cu·ªëi
      while (row.length < 4) {
        row.push(0);
      }
      
      // Ki·ªÉm tra xem h√†ng c√≥ thay ƒë·ªïi kh√¥ng
      if (JSON.stringify(row) !== JSON.stringify(newGrid[i])) {
        moved = true;
      }
      newGrid[i] = row;
    }
    return { grid: newGrid, moved, addedScore };
  };

  // S·ª≠ d·ª•ng useCallback ƒë·ªÉ ·ªïn ƒë·ªãnh h√†m `move`
  const move = useCallback((direction) => {
    setGrid(prevGrid => {
      if (gameOver) return prevGrid;

      let newGrid = prevGrid.map(row => [...row]);
      let rotations = 0;

      if (direction === 'right') rotations = 2;
      else if (direction === 'up') rotations = 3;
      else if (direction === 'down') rotations = 1;

      // 1. Quay l∆∞·ªõi ƒë·ªÉ di chuy·ªÉn sang tr√°i
      for (let i = 0; i < rotations; i++) {
        newGrid = rotateGrid(newGrid);
      }

      // 2. Di chuy·ªÉn sang tr√°i
      const { grid: movedGrid, moved, addedScore } = moveLeft(newGrid);

      if (moved) {
        // C·∫≠p nh·∫≠t ƒëi·ªÉm
        const newScore = score + addedScore;
        setScore(newScore);
        if (newScore > bestScore) {
          setBestScore(newScore);
          localStorage.setItem('best2048', newScore.toString());
        }

        // 3. Ho√†n t√°c ph√©p quay
        let finalGrid = movedGrid;
        // Quay 4 - N l·∫ßn ƒë·ªÉ tr·ªü v·ªÅ (N l√† s·ªë l·∫ßn quay ban ƒë·∫ßu)
        const counterRotations = (4 - rotations) % 4; 
        for (let i = 0; i < counterRotations; i++) {
          finalGrid = rotateGrid(finalGrid);
        }

        // 4. Th√™m √¥ m·ªõi
        addNewTile(finalGrid);

        // 5. Ki·ªÉm tra Game Over
        if (checkGameOver(finalGrid)) {
          setGameOver(true);
        }

        return finalGrid; // C·∫≠p nh·∫≠t state l∆∞·ªõi
      }

      return prevGrid; // Kh√¥ng di chuy·ªÉn, gi·ªØ nguy√™n l∆∞·ªõi
    });
  }, [score, bestScore, gameOver]); // Th√™m dependencies c·∫ßn thi·∫øt

  // --- X·ª≠ l√Ω s·ª± ki·ªán b√†n ph√≠m ---

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        const direction = e.key.replace('Arrow', '').toLowerCase();
        move(direction);
      }
    };

    // Th√™m listener
    window.addEventListener('keydown', handleKeyDown);
    // Cleanup
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [move]); // Ch·ªâ ph·ª• thu·ªôc v√†o `move` (l√† useCallback), gi√∫p t·ªëi ∆∞u

  // --- H√†m Reset ---

  const resetGame = () => {
    setGrid(initGrid());
    setScore(0);
    setGameOver(false);
    setWon(false);
  };

  // --- Styling cho √¥ (Tile Styling) ---

  const getTileColor = (value) => {
    const colors = {
      0: 'bg-gray-200',
      2: 'bg-amber-100',
      4: 'bg-amber-200',
      8: 'bg-orange-300',
      16: 'bg-orange-400',
      32: 'bg-orange-500',
      64: 'bg-red-400',
      128: 'bg-yellow-300',
      256: 'bg-yellow-400',
      512: 'bg-yellow-500',
      1024: 'bg-yellow-600',
      2048: 'bg-yellow-700'
    };
    return colors[value] || 'bg-purple-500';
  };

  const getTileTextColor = (value) => {
    return value > 4 ? 'text-white' : 'text-gray-700';
  };

  // --- JSX Render ---

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-100 to-blue-100 p-4">
      <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-md w-full">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-4xl font-bold text-gray-800">2048</h1>
          <button
            onClick={resetGame}
            className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-colors"
          >
            <RotateCcw size={20} />
            Ch∆°i l·∫°i
          </button>
        </div>

        <div className="flex gap-4 mb-6">
          <div className="bg-orange-400 rounded-lg p-3 flex-1 text-center">
            <div className="text-white text-sm font-semibold">ƒêI·ªÇM</div>
            <div className="text-white text-2xl font-bold">{score}</div>
          </div>
          <div className="bg-orange-500 rounded-lg p-3 flex-1 text-center">
            <div className="text-white text-sm font-semibold flex items-center justify-center gap-1">
              <Trophy size={16} />
              T·ªêT NH·∫§T
            </div>
            <div className="text-white text-2xl font-bold">{bestScore}</div>
          </div>
        </div>

        <div className="bg-orange-300 rounded-lg p-4 relative">
          <div className="grid grid-cols-4 gap-3">
            {grid.map((row, i) =>
              row.map((cell, j) => (
                <div
                  key={`${i}-${j}`}
                  className={`${getTileColor(cell)} ${getTileTextColor(cell)} w-16 h-16 rounded-lg flex items-center justify-center text-2xl font-bold transition-all duration-150 transform`}
                >
                  {cell !== 0 && cell}
                </div>
              ))
            )}
          </div>

          {gameOver && (
            <div className="absolute inset-0 bg-white bg-opacity-90 rounded-lg flex flex-col items-center justify-center">
              <div className="text-4xl font-bold text-red-500 mb-4">Game Over!</div>
              <button
                onClick={resetGame}
                className="bg-orange-500 hover:bg-orange-600 text-white px-6 py-3 rounded-lg font-semibold"
              >
                Th·ª≠ l·∫°i
              </button>
            </div>
          )}

          {won && !gameOver && (
            <div className="absolute inset-0 bg-yellow-400 bg-opacity-95 rounded-lg flex flex-col items-center justify-center">
              <div className="text-4xl font-bold text-white mb-4">B·∫°n th·∫Øng! üéâ</div>
              <div className="flex gap-3">
                <button
                  onClick={() => setWon(false)}
                  className="bg-white text-yellow-600 px-6 py-3 rounded-lg font-semibold"
                >
                  Ti·∫øp t·ª•c
                </button>
                <button
                  onClick={resetGame}
                  className="bg-orange-500 hover:bg-orange-600 text-white px-6 py-3 rounded-lg font-semibold"
                >
                  Ch∆°i l·∫°i
                </button>
              </div>
            </div>
          )}
        </div>

        <div className="mt-6 text-center text-gray-600 text-sm">
          <p className="font-semibold mb-2">C√°ch ch∆°i:</p>
          <p>D√πng ph√≠m m≈©i t√™n **‚Üê ‚Üí ‚Üë ‚Üì** ƒë·ªÉ di chuy·ªÉn √¥</p>
          <p>Gh√©p c√°c √¥ c√≥ c√πng s·ªë ƒë·ªÉ t·∫°o √¥ l·ªõn h∆°n</p>
          <p className="mt-2 text-orange-600 font-semibold">M·ª•c ti√™u: ƒê·∫°t √¥ 2048!</p>
        </div>
      </div>
    </div>
  );
};

export default Game2048;
